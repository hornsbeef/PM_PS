a)
Output generated by class Test + explanation added.
--- 1 ---// B object1 = new C(); -> object1 has: static type B; dynamic typ C;
        //object1.print(new A()); -> in Class B we look for print(that takes A) -> there is one
C 1     //then due to dynamic type C -> look if this function has been overwritten in class C -> public void print(A a) {System.out.println("C 1");}
C 2     //((C) object1).print(new B()); due to cast look directly in class C -> public void print(B b) {System.out.println("C 2");}
        //
--- 2 ---       //
        //A object2 = new B()   -> object 2: static A; dynamic B;
B 1     //((B) object2).print(new A()); -> due to cast -> in class B -> public void print(A a) {System.out.println("B 1");}
B 1     //object2.print(new C()); -> object 2: static type A -> uses print(A a) from class A ->
        //due to dynamic type B the function print(A a) from class B is used
--- 3 ---       //
        //A object3 = new C(); -> object3: static A; dynamic C;
C 1     //object3.print(new C()); -> in class A look for function compatible -> print(A a) -> dynamic->Class C -> public void print(A a) {System.out.println("C 1");}
C 1     //object3.print(new A()); -> in class A look for function compatible -> print(A a) -> dynamic->Class C -> public void print(A a) {System.out.println("C 1");}
C 1     //object3.print(new B()); -> in class A look for function compatible -> print(A a) -> dynamic->Class C -> public void print(A a) {System.out.println("C 1");}
C 2     //((C) object3).print(new B()); -> due to cast look directly in Class C -> public void print(B b) {System.out.println("C 2");}
C 3     //((C) object3).print(new C()); -> due to cast look directly in Class C -> public void print(C c) {System.out.println("C 3");}
        //
--- 4 ---       //
        //C object4 = new C(); -> object4: static and dynamic C;
C 3     //object4.print(new C()); -> static C -> look in Class C -> public void print(C c) {System.out.println("C 3");}
C 1     //object4.print(new A()); -> static C -> look in Class C -> public void print(A a) {System.out.println("C 1");}
C 2     //object4.print(new B()); -> static C -> look in Class C -> public void print(B b) {System.out.println("C 2");}
        //
--- 5 ---       //
        //B object5 = new B(); -> static and dynamic B;
B 2     //object5.print(new C()); -> static B ->look in Class B -> print(new C()) compatible to print(B b) and closer than (A a) -> public void print(B b) {System.out.println("B 2");}
B 2     //object5.print(new B()); -> static B ->look in Class B -> fits directly ->public void print(B b) {System.out.println("B 2");}
B 1     //object5.print(new A()); -> static B ->look in Class B -> fits directly ->public void print(A a) {System.out.println("B 1");}
        //
--- 6 ---       //
        //Object object6 = new C(); -> static Object; dynamic C;
C 2     //((C) object6).print(new B()); -> cast to static C ->look there for compat function -> public void print(B b) {System.out.println("C 2");}
C 1     //((A) object6).print(new A()); -> cast to static A ->look there for compat function -> print(A a)-> use the overwritten one from dynamic class C -> public void print(A a) {System.out.println("C 1");}
C 2     //((B) object6).print(new B()); -> cast to static B ->look there for compat function -> print(B b)-> use the overwritten one from dynamic class C -> public void print(B b) {System.out.println("C 2");}
        //
--- 7 ---       //
        //Object object7 = new A(); -> static Object; dynamic A;
A 1     //((A) object7).print(new C()); -> cast to A -> look there for function compatible to print(new C()) -> as C is Subclass of B, and B is subclass of A ->
        //-> print(new C()) is compatible to print(A a) -> dynamic A -> use function from Class A -> public void print(A a) {System.out.println("A 1");}
--- 8 ---       //
        //Object object8 = new B(); -> static Object; dynamic B;
B 1     //((B) object8).print(new A()); -> cast to B -> look there for compat funct to print(new A()): print(A a) -> dynamic B: in class B -> public void print(A a) {System.out.println("B 1");}
B 1     //((A) object8).print(new A()); -> cast to A -> look there for compat funct to print(new A()): print(A a) -> dynamic B: in class B -> public void print(A a) {System.out.println("B 1");}

b) Explanation of static and dynamic binding:
In java, binding refers to the process of linking a method call to its corresponding method implementation.
Binding decides which method implementation is used when a method is called.
Binding can happen either at runtime or at compile time.

The static binding uses Type information for binding while Dynamic binding uses Objects to resolve to bind.

Static binding occurs at compile-time and is used for:
    Private methods
    Final methods
    Static methods
        (Methods that are marked as final, static, or private cannot be overridden and are therefore use static binding, where the method to call is determined at compile-time.)
    Method overloading
In static binding, the method to be called is determined by the type of the reference variable,
not the actual object it refers to. This allows the compiler to optimize the method call during compilation.
In this exercise, no methods that are private | final | static were called.
Method overloading can be observed for example in class C:
public class C extends B {
	public void print(A a) {System.out.println("C 1");}
	public void print(B b) {System.out.println("C 2");}
	public void print(C c) {System.out.println("C 3");}
}
Even though there is method overloading here, there is also method overriding, as print(A a) and print(B b) override the implementations
of the superclasses of C.

Dynamic binding occurs at runtime and is used for:
    Method overriding
    Virtual methods (non-private, non-final, non-static methods)
In dynamic binding, the method to be called is determined by the actual type of the object, not the reference type.
This provides more flexibility but has a small performance overhead.

